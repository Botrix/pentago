#!/usr/bin/env python

from __future__ import division
import os
import re
import sqlite3
import fileinput
from geode import *
from geode.value import parser
from pentago.old.interface import *
from utility.ashelve import *

# Properties
props = PropManager()
game = props.add('game','defense').set_allowed('defense'.split())
jobs = props.add('jobs',1).set_abbrev('j')
stones = props.add('stones',6).set_abbrev('n')
bits = props.add('bits',26).set_abbrev('b')
verbose = props.add('verbose',True).set_abbrev('v')
action = props.add('action','list').set_allowed('gen list missing cleanup dump'.split())
parser.parse(props,'Opening book generator',positional=[action])

# Fork if desired
assert 1<=jobs()<32
for _ in xrange(jobs()-1):
  assert action()=='gen'
  print 'forking'
  if not os.fork():
    break

# Open the book
book = ashelf('opening-%s.db'%game())

def count(boards):
  boards = asarray(boards)
  return sum(to_table(boards).reshape(*(boards.shape+(36,)))!=0,axis=-1)

def show_result(moves):
  return 'black wins (possibly in %d moves)'%moves if moves<=36 else 'tie'

def list_book():
  entries = book.dict(strict=False)
  keys = asarray(list(entries.keys()),dtype=uint64)
  counts = count(keys)
  for n in xrange(stones()+1):
    for board in sort(keys[counts==n]):
      print 'board %d, stones %d, %s'%(board,count(board),show_result(entries[board]))
      if verbose():
        print show_board(board),'\n'

def list_missing():
  keys = book.keys(strict=False)
  for n in xrange(stones()+1):
    for board in all_boards(n,False):
      if board not in keys: 
        print 'board %d, stones %d'%(board,n)
        if verbose():
          print show_board(board),'\n'

def solve_board(board):
  # Since we don't clear the table each time, the depth estimate is approximate only
  turn = count(board)&1
  flipboard = flipto(board,turn)
  for depth in xrange(1-turn,40,2):
    print 'searching %d to depth %d'%(board,depth)
    d,v = divmod(engine.simple_evaluate(depth,flipboard),4)
    v = (-1)**turn*(v-1)
    assert v>=0
    if d>=36:
      result = depth if v>0 else 40
      print 'solved %d: depth %d, %s'%(board,depth,show_result(result))
      return result

def scrape_table():
  boards,scores = read_table(stones(),36)
  boards = standardize(boards)
  print 'found %d interesting table entries'%len(boards)
  for board,score in zip(boards,scores):
    turn = count(board)&1
    board = flipto(board,turn)
    d,v = divmod(score,4) 
    v = (-1)**turn*(v-1)
    assert d>=36 and v>=0
    try:
      with book.lock(board) as entry:
        if entry:
          assert (entry()<=36)==(v>0)
        else:
          result = 0 if v>0 else 40
          print 'quick solved %d: count %d, %s'%(board,count(board),show_result(result))
          entry.set(result)
    except Locked:
      pass

def gen_book():
  engine.init_table(bits())
  for n in xrange(stones()+1):
    for board in all_boards(n):
      try:
        with book.lock(board) as entry:
          if not entry:
            print 'solving board %d, stones %d'%(board,n)
            print show_board(board)
            entry.set(solve_board(board))
            scrape_table()
      except Locked:
        pass

def cleanup():
  book.delete_locked()
  book.delete_if_skey_like('array%')

if action()=='list':
  list_book()
elif action()=='missing':
  list_missing()
elif action()=='gen':
  gen_book()
elif action()=='cleanup':
  cleanup()
elif action()=='dump':
  book.dump()
