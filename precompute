#!/usr/bin/env python
'''Pentago precomputation code'''

from __future__ import division
import os
import sys
from numpy import *
from other.core import *
from other.core.value import parser

def bit(n,x,y,flip=False,rotate=False):
  assert 0<=x<n
  assert 0<=y<n
  if flip:
    x,y = y,x
  if rotate:
    x,y = n-1-y,x
  return 1<<(n*x+y)

def popcount(x):
  count = 0
  while x:
    x &= ~(x&-x)
    count += 1
  return count

def bits(x):
  if not x:
    return '0b0'
  s = ''
  while x:
    s = '01'[x&1]+s
    x //= 2
  return '0b'+s

def cpp_array(format,table):
  table = asarray(table)
  def init(a):
    if a.shape:
      return '{'+','.join(map(init,a))+'}'
    else:
      return format%a
  return ''.join('[%d]'%n for n in table.shape) + ' = ' + init(table)

def ahash(*args):
    return hash(''.join(asarray(a).tostring() for a in args))

@cache
def win_contributions():
  # List the various ways of winning
  wins = []
  # Off-centered diagonal 5 in a row
  n = 6
  for x in 0,1:
    for y in 0,1:
      p = 0
      for i in -2,-1,0,1,2:
        p |= bit(n,2+x+i,2+y+i*(-1 if x==y else 1))
      wins.append(p)
  # Axis aligned 5 in a row
  for flip in 0,1:
    for x in 0,1:
      for y in xrange(6):
        p = 0
        for i in xrange(5):
          p |= bit(n,x+i,y,flip=flip)
        wins.append(p)
  # Centered diagonal 5 in a row
  for rotate in 0,1:
    for x in 0,1:
      p = 0
      for i in xrange(5):
        p |= bit(n,i+x,i+x,rotate=rotate)
      wins.append(p)

  # Check that 5 bits are set in each
  for w in wins:
    assert popcount(w)==5

  # There should be 4*3*2+4+4 == 32 ways to win.
  # The first four of these are special: they require contributions from three quadrants.
  # The remaining 28 require contributions from only two quadrants.
  assert len(wins)==32==4*3*2+4+4

  # For each possible value of each quadrant, determine all the ways that quadrant can
  # contribute to victory.
  table = zeros((4,512),dtype=int64)
  for qx in xrange(2):
    for qy in xrange(2):
      q = 2*qx+qy
      for v in xrange(512):
        b = 0
        qb = 0
        for x in xrange(3):
          for y in xrange(3):
            qb |= bit(n,3*qx+x,3*qy+y)
            if v&bit(3,x,y):
              b |= bit(n,3*qx+x,3*qy+y)
        for i,w in enumerate(wins):
          if w&qb and not ~b&(w&qb):
            table[q,v] |= 1<<(2*i)
  assert ahash(table)==5134745501271341312

  # Format table as a const C++ array 
  return 'static const uint64_t win_contributions' + cpp_array('0x%xL',table)+';\n'

@cache
def rotations():
  n = 3
  table = zeros((512,2),dtype=int16)
  for v in xrange(512):
    left = 0
    right = 0
    for x in xrange(3):
      for y in xrange(3):
        if v&bit(n,x,y):
          left |= bit(n,2-y,x)
          right |= bit(n,y,2-x)
    assert popcount(v)==popcount(left)==popcount(right)
    table[v] = left,right
  assert ahash(table)==-631278374917950784
  return 'static const uint16_t rotations' + cpp_array('0x%x',table)+';\n'

@cache
def reflections():
  n = 3 
  table = zeros((512,2),dtype=int16)
  for v in xrange(512):
    rx,ry = 0,0
    for x in xrange(3):
      for y in xrange(3):
        if v&bit(n,x,y):
          rx |= bit(n,2-x,y)
          ry |= bit(n,x,2-y)
    assert popcount(v)==popcount(rx)==popcount(ry)
    table[v] = rx,ry
  assert ahash(table)==5787381149236214080
  return 'static const uint16_t reflections' + cpp_array('0x%x',table)+';\n'

@cache
def packings():
  '''There are 3**9 = 19683 possible states in each quadrant.  3**9 < 2**16, so we can store
  a quadrant state in 16 bits using radix 3.  However, radix 3 is inconvenient for computation,
  so we need lookup tables to go to and from packed form.'''
  pack = zeros(2**9,dtype=int16)
  for v in xrange(512):
    pv = 0
    for i in xrange(9):
      if v&2**i:
        pv += 3**i
    pack[v] = pv
  unpack = zeros((3**9,2),dtype=int16)
  for v in xrange(3**9):
    vv = v
    p0,p1 = 0,0
    for i in xrange(9):
      c = vv%3
      if c==1:
        p0 += 2**i
      elif c==2:
        p1 += 2**i
      vv //= 3
    unpack[v] = p0,p1
  assert all(pack[unpack[:,0]]+2*pack[unpack[:,1]]==arange(3**9))
  assert ahash(pack)==3488108636539942373
  assert ahash(unpack)==-3185216453998868236
  return ['static const uint16_t pack'+cpp_array('%d',pack)+';\n',
          'static const uint16_t unpack'+cpp_array('0x%x',unpack)+';\n']

@cache
def moves():
  '''Given a quadrant, compute all possible moves by player 0 as a function of the set of filled spaces, stored as a nested array.'''
  moves = []
  for filled in xrange(2**9):
    mv = []
    free = ~filled
    for i in xrange(9):
      b = 1<<i
      if free&b:
        mv.append(b)
    assert len(mv)==9-popcount(filled)
    moves.append(mv)
  # Pack into a flat nested array
  sizes = asarray(map(len,moves))
  offsets = hstack([0,cumsum(sizes)])
  flat = asarray([x for mv in moves for x in mv])
  assert len(flat)==offsets[-1]
  assert len(flat)<2**16
  assert ahash(offsets)==-1634244574290319362
  assert ahash(flat)==72249306322598272
  return ('static const uint16_t move_offsets'+cpp_array('%d',offsets)
      +';\nstatic const uint16_t move_flat'+cpp_array('%d',flat)+';\n')

if __name__=='__main__':
  prefix = PropManager.add('prefix','gen').set_help('directory to store generated files')
  parser.parse('Pentago precomputation script',positional=[prefix])
  prefix = prefix()
  if not os.path.exists(prefix):
    os.makedirs(prefix)
  note = '// Autogenerated by helper: do not edit directly\n'
  def save(name,array):
    open('%s/%s.h'%(prefix,name),'w').write(note+array)
  save('win',win_contributions())
  save('rotate',rotations())
  save('reflect',reflections())
  save('pack',packings()[0])
  save('unpack',packings()[1])
  save('move',moves())
