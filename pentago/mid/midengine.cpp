// Solve positions near the end of the game using downstream retrograde analysis

#include <pentago/mid/midengine.h>
#include <pentago/base/count.h>
#include <pentago/base/symmetry.h>
#include <pentago/high/board.h>
#include <pentago/search/superengine.h>
#include <pentago/utility/aligned.h>
#include <pentago/utility/ceil_div.h>
#include <pentago/utility/char_view.h>
#include <pentago/utility/debug.h>
#include <pentago/utility/memory.h>
#include <geode/array/view.h>
#include <geode/python/wrap.h>
#include <geode/utility/Log.h>
namespace pentago {

using Log::cout;
using std::endl;

// Flip to enable debugging
//#define MD(...) __VA_ARGS__
#define MD(...)

static superinfos_t transform_superinfos(const symmetry_t s, const superinfos_t a) {
  superinfos_t sa;
  sa.known   = transform_super(s,a.known);
  sa.win     = transform_super(s,a.win);
  sa.notlose = transform_super(s,a.notlose);
  return sa;
}

typedef uint64_t set_t;

template<int k> static inline void subsets_helper(Array<set_t>& all, const int n, const set_t high) {
  for (int i=k-1;i<n;i++)
    subsets_helper<k-1>(all,i,i|high<<5);
}
template<> inline void subsets_helper<0>(Array<set_t>& all, const int n, const set_t high) {
  all.append(high);
}

// All k-subsets of [0,n-1], packed into 64-bit ints with 5 bits for each entry.
// I.e., the set {a < b < c} has value a|b<<5|c<<10.  We order sets in large-entry-major order;
// the first 3-set of 10 is {0,1,2}, followed by {0,1,3}.
static Array<const set_t> subsets(const int n, const int k) {
  GEODE_ASSERT(0<=n && n<=18);
  Array<set_t> all;
  if (0<=k && k<=n)
    switch (k) {
      #define K(k) case k: subsets_helper<k>(all,n,0); break;
      K(0) K(1) K(2) K(3) K(4) K(5) K(6) K(7) K(8) K(9)
      #undef K
      default: GEODE_ASSERT(k<=9);
    }
  GEODE_ASSERT(uint64_t(all.size())==choose(n,k));
  return all;
}

/* In the code below, we will organized pairs of subsets of [0,n-1] into two dimensional arrays.
 * The first dimension records the player to move, the second the other player.  The first dimension
 * is organized according to the order produced by subsets(), and the second is organized by the
 * order produced by subsets *relative* to the first set (a sort of semi-direct product).  For example,
 * if our root position has slice 32, or 4 empty spots, the layout is
 *
 *   n 0 : ____
 *   n 1 : 0___  _0__  __0_ ___0
 *
 *   n 2 : 01__  0_1_  0__1
 *         10__  _01_  _0_1
 *         1_0_  _10_  __01
 *         1__0  _1_0  __10
 *
 *   n 3 : 100_  10_0  1_00
 *         010_  01_0  _100
 *         001_  0_10  _010
 *         00_1  0_01  _001
 *
 *   n 4 : 0011
 *         0101
 *         1001
 *         0110
 *         1010
 *         1100
 */

static int count(const int spots, const int more) {
  return CHECK_CAST_INT(choose(spots,more)*choose(more,more/2));
}

static int bottleneck(const int spots) {
  const int slice = 36-spots;
  int worst = count(spots,spots);
  for (const int n : range(spots+1)) {
    const int k0 = (slice+n)/2-(slice+(n&1))/2, // Player to move
              k1 = n-k0; // Other player
    worst = max(worst,count(spots,n)+count(spots,n+1)+ceil_div(choose(spots,k1),2));
  }
  return worst;
}

Array<uint8_t> midsolve_workspace(const int min_slice) {
  // Allocate enough memory for 18 stones, which is the most we'll need
  return char_view_own(aligned_buffer<halfsupers_t>(bottleneck(36-min_slice)));
}

static RawArray<halfsupers_t,2> grab(RawArray<uint8_t> workspace, const bool end, const int nx, const int ny) {
  RawArray<halfsupers_t> work(workspace.size()/sizeof(halfsupers_t),(halfsupers_t*)workspace.data());
  const auto flat = end ? work.slice(work.size()-nx*ny,work.size()) : work.slice(0,nx*ny);
  return flat.reshape(nx,ny);
}

// Precompute some combinations, and store in a triangular array.  Generated by
//   '{%s}'%','.join('{%s}'%','.join(str(choose(n,k)) for k in xrange(10+1)) for n in xrange(18+1))
static const uint16_t combinations[18+1][10+1] = {{1,0,0,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0,0,0,0},{1,2,1,0,0,0,0,0,0,0,0},{1,3,3,1,0,0,0,0,0,0,0},{1,4,6,4,1,0,0,0,0,0,0},{1,5,10,10,5,1,0,0,0,0,0},{1,6,15,20,15,6,1,0,0,0,0},{1,7,21,35,35,21,7,1,0,0,0},{1,8,28,56,70,56,28,8,1,0,0},{1,9,36,84,126,126,84,36,9,1,0},{1,10,45,120,210,252,210,120,45,10,1},{1,11,55,165,330,462,462,330,165,55,11},{1,12,66,220,495,792,924,792,495,220,66},{1,13,78,286,715,1287,1716,1716,1287,715,286},{1,14,91,364,1001,2002,3003,3432,3003,2002,1001},{1,15,105,455,1365,3003,5005,6435,6435,5005,3003},{1,16,120,560,1820,4368,8008,11440,12870,11440,8008},{1,17,136,680,2380,6188,12376,19448,24310,24310,19448},{1,18,153,816,3060,8568,18564,31824,43758,48620,43758}};
#define choose(n,k) ({ \
  const int n_ = (n), k_ = (k); \
  assert(unsigned(n_)<=18 && unsigned(k_)<=10); \
  combinations[n_][k_]; })

template<int spots,int n> GEODE_NEVER_INLINE static void
midsolve_loop(const board_t root, const bool parity, Hashtable<board_t,superinfos_t>& results, RawArray<uint8_t> workspace) {
  const int slice = 36-spots;
  const auto black_root = unpack(root,0),
             white_root = unpack(root,1);
  const auto root0 = (slice+n)&1 ? white_root : black_root,
             root1 = (slice+n)&1 ? black_root : white_root;
  const int k0 = (slice+n)/2-(slice+(n&1))/2, // Player to move
            k1 = n-k0; // Other player
  const auto sets0 = subsets(spots,k0),
             sets1 = subsets(spots,k1),
             sets1p = subsets(spots-k0,k1);
  const int sets0p_size = choose(spots-k1,k0+1);
  GEODE_ASSERT(!(uint64_t(workspace.data())&(sizeof(halfsupers_t)-1)));
  const auto input = grab(workspace,n&1,sets1.size(),sets0p_size).const_();
  const auto output = grab(workspace,!(n&1),sets0.size(),sets1p.size());
  const int all_wins_start = CHECK_CAST_INT(memory_usage(n&1?output.const_():input));
  const RawArray<halfsuper_t> all_wins1(sets1.size(),(halfsuper_t*)(workspace.data()+all_wins_start));
  GEODE_ASSERT(memory_usage(input)+memory_usage(output)+memory_usage(all_wins1) <= uint64_t(workspace.size()));

  // List empty spots as bit indices into side_t
  uint8_t empty[spots];
  {
    const auto free = side_mask&~(black_root|white_root);
    int next = 0;
    for (int i=0;i<64;i++)
      if (free&side_t(1)<<i)
        empty[next++] = i;
    GEODE_ASSERT(next==36-slice);
  }
  #define set_side(count,set) ({ \
    const int c_ = (count); \
    const set_t set_ = (set); \
    side_t s_ = 0; \
    for (int i=0;i<c_;i++) \
      s_ |= side_t(1)<<empty[set_>>5*i&0x1f]; \
    s_; })
  MD(const auto str_set = [=](const int k0, const set_t set0, const int k1, const set_t set1, const bool flip) {
    string s(spots,'_');
    for (int i=0;i<k0;i++) s[set0>>5*i&0x1f] = flip ? '1' : '0';
    for (int i=0;i<k1;i++) s[set1>>5*i&0x1f] = flip ? '0' : '1';
    return s;
  };)

  // Evaluate whether the other side wins for all possible sides
  for (int s1=0;s1<sets1.size();s1++)
    all_wins1[s1] = halfsuper_wins(root1 | set_side(k1,sets1[s1]))[(n+parity)&1];

  // Iterate over set of stones of player to move
  for (int s0=0;s0<output.m;s0++) {
    // Construct side to move
    const set_t set0 = sets0[s0];
    const side_t side0 = root0 | set_side(k0,set0);

    // Make a mask of filled spots
    uint32_t filled0 = 0;
    for (int i=0;i<k0;i++)
      filled0 |= 1<<(set0>>5*i&0x1f);

    // Evaluate whether we win for side0 and all child sides
    const halfsuper_t wins0 = halfsuper_wins(side0)[(n+parity)&1];

    // List empty spots after we place s0's stones
    uint8_t empty1[spots-k0];
    {
      const auto free = side_mask&~side0;
      int next = 0;
      for (int i=0;i<spots;i++)
        if (free&side_t(1)<<empty[i])
          empty1[next++] = i;
      GEODE_ASSERT(next==spots-k0);
    }

    // Precompute wins after we place s0's stones
    halfsuper_t child_wins0[spots-k0];
    for (int i=0;i<spots-k0;i++)
      child_wins0[i] = halfsuper_wins(side0|side_t(1)<<empty[empty1[i]])[(n+parity)&1];

    // Iterate over set of stones of other player
    for (int s1p=0;s1p<sets1p.size();s1p++) {
      const auto set1p = sets1p[s1p];
      // Convert indices
      uint32_t filled1 = 0;
      int s1 = 0;
      for (int i=0;i<k1;i++) {
        const int s1pi = set1p>>5*i&0x1f,
                  s1i = empty1[s1pi];
        filled1 |= 1<<s1i;
        s1 += choose(s1i,i+1);
      }

      // Print board
      MD({
        const auto board = flip_board(pack(side0,root1|set_side(k1,sets1[s1])),(slice+n)&1);
        cout << "\ncomputing slice "<<slice<<"+"<<n<<", k0 "<<k0<<", k1 "<<k1
          <<", fill "<<str_set(k0,set0,k1,sets1[s1],(slice+n)&1)
          <<", board "<<board
          <<", s0 "<<s0<<", s1p "<<s1p<<", s1 "<<s1<<endl;
        if (0) cout << str_board(board)<<endl;
      })

      // Sweep through once to precompute an uniform index shift
      int shift = 0;
      {
        int zeros = 1, ones = 0;
        for (int i=0;i<spots;i++) {
          if (filled0&1<<i)
            shift += choose(i-ones,++zeros);
          else if (filled1&1<<i)
            ones++;
        }
      }

      // Consider each move in turn
      halfsupers_t us;
      {
        us.x = us.y = halfsuper_t(0);
        const uint32_t moves = ~(filled0|filled1);
        int zeros = 0, ones = 0, base = shift;
        for (int i=0;i<spots;i++) {
          if (moves&1<<i) {
            const int s0p = base+choose(i-ones,zeros+1);
            const auto cwins = child_wins0[i-zeros];
            const halfsupers_t child = input(s1,s0p);
            us.x |= cwins | child.x; // win
            us.y |= cwins | child.y; // not lose
            MD({
              const auto child_set0 = set0|i<<5*k0;
              const auto board = pack(root1|set_side(k1,sets1[s1]),root0|set_side(k0+1,child_set0));
              const auto flip = flip_board(board,(slice+n+1)&1);
              cout << "child "<<str_set(k1,sets1[s1],k0+1,child_set0,(slice+n+1)&1)
                <<", board "<<flip<<", set "<<child_set0<<", s1 "<<s1<<", s0p "<<s0p
                <<" (shift "<<shift<<", base "<<base<<", i-ones "<<i-ones<<")"<<endl;
              if (0) cout << str_board(flip)<<endl;
              GEODE_ASSERT(child.x==rmax(~super_evaluate_all(false,100,board)));
              GEODE_ASSERT(child.y==rmax(~super_evaluate_all(true ,100,board)));
            })
          } else if (filled0&1<<i) {
            base += choose(i-ones,zeros+1)-choose(i-ones,zeros+2);
            zeros++;
          } else
            ones++;
        }
      }

      // Account for immediate results
      const halfsuper_t wins1 = all_wins1[s1],
                        inplay = ~(wins0 | wins1);
      us.x = (inplay & us.x) | (wins0 & ~wins1); // win
      us.y = (inplay & us.y) | (slice+n==36 ? wins0 | ~wins1 : wins0); // not lose

      // Test if desired
      MD({
        const auto board = pack(side0,root1|set_side(k1,sets1[s1]));
        GEODE_ASSERT(us.x==super_evaluate_all(true ,100,board));
        GEODE_ASSERT(us.y==super_evaluate_all(false,100,board));
      })

      // If we're far enough along, remember results
      if (n <= 1) {
        superinfos_t info;
        const auto all = ~halfsuper_t(0);
        info.known   = (n+parity)&1 ? merge(0, all) : merge( all,0);
        info.win     = (n+parity)&1 ? merge(0,us.x) : merge(us.x,0);
        info.notlose = (n+parity)&1 ? merge(0,us.y) : merge(us.y,0);
        const uint32_t filled_black = slice+n&1 ? filled1 : filled0,
                       filled_white = slice+n&1 ? filled0 : filled1;
        board_t board = root;
        for (int i=0;i<spots;i++)
          board += ((filled_black>>i&1)+2*(filled_white>>i&1))*pack(side_t(1)<<empty[i],side_t(0));
        results.set(board,info);
      }

      // Negate and apply rmax in preparation for the slice above
      halfsupers_t above;
      above.x = rmax(~us.y);
      above.y = rmax(~us.x);
      output(s0,s1p) = above;
    }
  }
}

Hashtable<board_t,superinfos_t> midsolve_internal(const board_t root, const bool parity, RawArray<uint8_t> workspace) {
  new_<high_board_t>(root,false); // Verify that we have a consistent board
  const int slice = count_stones(root);
  GEODE_ASSERT(18<=slice && slice<=36);
  const int spots = 36-slice;
  GEODE_ASSERT(workspace.size()>=bottleneck(spots));

  // Compute all slices
  Hashtable<board_t,superinfos_t> results;
  #define N(n) case n: midsolve_loop<s,n<=s?n:0>(root,parity,results,workspace);
  #define S(s_) \
    case s_: { \
      const int s = (s_); \
      switch (s) { \
        N(18) N(17) N(16) N(15) N(14) N(13) N(12) N(11) N(10) N(9) N(8) N(7) N(6) N(5) N(4) N(3) N(2) N(1) N(0) \
      } \
      break; \
    }
  switch (spots) {
    S(0) S(1) S(2) S(3) S(4) S(5) S(6) S(7) S(8) S(9) S(10) S(11) S(12) S(13) S(14) S(15) S(16) S(17) S(18)
  }
  return results;
}

Hashtable<board_t,int> midsolve(const board_t root, const bool parity, const RawArray<const board_t> boards,
                                RawArray<uint8_t> workspace) {
  // Compute
  const auto supers = midsolve_internal(root,parity,workspace);

  // Extract results
  Hashtable<board_t,int> results;
  for (const auto board : boards) {
    // We can't superstandardize, since that can break parity.  Instead, we check all local rotations manually.
    for (int i=0;i<256;i++) {
      const local_symmetry_t s(i);
      const auto p = supers.get_pointer(transform_board(s,board));
      if (p) {
        const superinfos_t r = transform_superinfos(s.inverse(),*p);
        if (r.known(0)) {
          results.set(board,r.win(0)+r.notlose(0)-1);
          goto found;
        }
      }
    }
    throw RuntimeError(format("midsolve failure: root %lld, parity %d, board %lld\n%s\n%s",
      root,parity,board,str_board(root),str_board(board)));
    found:;
  }
  return results;
}

static void midsolve_internal_test(const board_t board, const bool parity) {
  const int slice = count_stones(board);
  const auto workspace = midsolve_workspace(slice);
  const auto results = midsolve_internal(board,parity,workspace);
  GEODE_ASSERT(results.size()==37-slice); // Only mostly true due to superstandardization, but still useful to assert
  for (const auto& r : results) {
    const auto rboard = r.key();
    const bool turn = count_stones(r.key())&1;
    const auto rs = r.data();
    GEODE_ASSERT(popcount(rs.known)==128);
    cout << format("slice %d, board %19lld, parity %d: win %3d, tie %3d, loss %3d",
                   slice,rboard,parity,popcount(rs.win),popcount(~rs.win&rs.notlose),popcount(~(rs.win|rs.notlose)))<<endl;
    for (int a=0;a<2;a++) {
      super_t correct = super_evaluate_all(a,100,flip_board(rboard,turn));
      GEODE_ASSERT(!((correct^(a?rs.win:rs.notlose))&rs.known));
    }
  }
}

}
using namespace pentago;

void wrap_midengine() {
  GEODE_FUNCTION(midsolve_workspace)
  GEODE_FUNCTION(midsolve)
  GEODE_FUNCTION(midsolve_internal_test)
}
