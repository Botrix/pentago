#!/usr/bin/env python

from __future__ import division
from other.core import *
from other.core.value import parser
from other.core.utility import tryfile
from interface import *
import time
import tempfile

# Declare properties as global variables
section = PropManager.add('section','').set_help('numbers of black and white stones in each quadrant (''.join(ravel(section)))').set_required(1)
block_size = PropManager.add('block_size',8).set_help('block size along all four quadrant dimensions')
filter = PropManager.add('filter',1).set_help('filter type to precondition zlib compression')
level = PropManager.add('level',21).set_help('zlib compression level')
dir = PropManager.add('dir','data').set_help('top level data directory')
recurse = PropManager.add('recurse',False).set_help('automatically recurse into child sections')
symmetries = PropManager.add('symmetries',8).set_help('number of symmetries used to standardize sections')
force = PropManager.add('force',False).set_help('recompute section even if it already exists')
verify_samples = PropManager.add('verify',0).set_help('if nonzero, load tensor file and verify rather than computing, using the given number of samples')
nop = PropManager.add('nop',False).set_help('do nothing')
cpu_threads = PropManager.add('cpu_threads',-1).set_abbrev('j').set_help('number of cpu threads')
io_threads = PropManager.add('io_threads',-1).set_abbrev('i').set_help('number of io threads')
history = PropManager.add('history','').set_help('record thread execution history to given file')
samples = PropManager.add('samples',1024).set_help('number of sparse samples to save to a separate file')
sparse_verify_samples = PropManager.add('sparse',0).set_help('verify (at most) the given number of sparse samples')

def show_section(s):
  return '%d-'%sum(s)+''.join(map(str,ravel(s)))

def section_file(s):
  return os.path.join(dir,'section-%s.pentago'%show_section(s))

def sparse_file(s):
  return os.path.join(dir,'sparse-%s.try'%show_section(s))

def child_section(section,q):
  child = section.copy()
  turn = int(sum(section))&1
  child[q,turn] += 1
  return child if all(sum(child,axis=1)<=9) else None

def child_section_shape(section,q):
  '''The shape of a child section of the given section, or () if the child doesn't exist'''
  child = child_section(section,q)
  if child is None:
    return zeros(4,int)
  return section_shape(child)

def child_reader(readers,section,q):
  child = child_section(section,q)
  if child is None:
    return None
  reader, = [r for r in readers if all(r.header.section==standardize_section(child,symmetries))]
  return reader

def memory(*arrays):
  mem = sum(a.view(uint8).size for a in arrays)
  return '%dM'%ceil(mem/2**20)

def compute_pass(writer,first_pass,readers,order):
  # Given an ordering of the dimensions of the goal tensor A_ijkl, compute the result of moves
  # along the last two dimensions according to the ordering

  # Ponder the shape of things
  section = writer.header.section
  shape = writer.header.shape
  blocks = writer.header.blocks
  shape2 = child_section_shape(section,order[2])
  shape3 = child_section_shape(section,order[3])
  block_shape = writer.header.block_shape(0)
  reader2 = child_reader(readers,section,order[2])
  reader3 = child_reader(readers,section,order[3])

  # Allocate three (potentially very large) arrays
  dest = empty((block_shape[order[0]],block_shape[order[1]],shape [order[2]],shape [order[3]],2,4),uint64)
  src2 = empty((block_shape[order[0]],block_shape[order[1]],shape2[order[2]],shape [order[3]],2,4),uint64)
  src3 = empty((block_shape[order[0]],block_shape[order[1]],shape [order[2]],shape3[order[3]],2,4),uint64)
  Log.write('memory: dest %s, src2 %s, src3 %s, total %s'%(memory(dest),memory(src2),memory(src3),memory(dest,src2,src3)))

  def part(array,*shape):
    return array.reshape(-1,2,4)[:product(shape)].reshape(shape+(2,4))

  # Prepare for sampling
  sparse = sparse_sample_t(writer,samples) if first_pass else None

  # Loop over block slices in the first two dimensions, computing two dimensional block slices spanning the last two dimensions
  clear_thread_times()
  counts = zeros(3,uint64)
  for i in xrange(blocks[order[0]]):
    for j in xrange(blocks[order[1]]):
      with Log.scope('slice %d / %d'%(i*blocks[order[1]]+j,blocks[order[0]]*blocks[order[1]])):
        block = zeros(4)
        block[order[:2]] = i,j
        block_shape = writer.header.block_shape(block)
        dest_part = part(dest,block_shape[order[0]],block_shape[order[1]],shape [order[2]],shape [order[3]])
        src2_part = part(src2,block_shape[order[0]],block_shape[order[1]],shape2[order[2]],shape [order[3]])
        src3_part = part(src3,block_shape[order[0]],block_shape[order[1]],shape [order[2]],shape3[order[3]])
        if reader2:
          endgame_read_block_slice(child_section(section,order[2]),reader2,order,i,j,src2_part)
        if reader3:
          endgame_read_block_slice(child_section(section,order[3]),reader3,order,i,j,src3_part)
        counts += endgame_compute_block_slice(writer,order,i,j,dest_part,src2_part,src3_part,bool(first_pass))
        endgame_write_block_slice(writer,first_pass,order,i,j,dest_part,sparse)
        report_thread_times(False)

  # Done with this pass!
  writer.finalize()

  # Write extra data
  if first_pass:
    Log.write('section %s win counts: black %d, white %d, total %d'%(show_section(section),counts[0],counts[1],counts[2]))
    assert len(sparse.boards)==len(sparse.wins)==samples
    tryfile.write(sparse_file(section),{'stones':int(sum(section)),'section':section,'boards':sparse.boards,'wins':sparse.wins})


def section_children(section):
  turn = int(sum(section))&1
  children = []
  for q in xrange(4):
    child = child_section(section,q)
    if child is not None:
      child = standardize_section(child,symmetries)
      if not [() for c in children if all(child==c)]:
        children.append(child)
  return children

exist_set = set()
def exists(file):
  return file in exist_set or os.path.exists(file)

def compute(section):
  '''Compute a single section, optionally recursing down to children'''

  # Does the file already exist?
  if not force() and exists(section_file(section)):
    Log.write('skipping existing section %s'%show_section(section))
    return

  # Compute children
  children = section_children(section)
  Log.write('section %s depends on [%s]'%(show_section(section),','.join(map(show_section,children))))

  # Recurse into children if allowed
  for child in children:
    if not exists(section_file(child)):
      if not recurse():
        raise RuntimeError('section %s depends on missing section %s, but recursion is not allowed'%(show_section(section),show_section(child)))
      compute(child)

  # Compute section
  with Log.scope('compute %s'%show_section(section)):
    if nop():
      exist_set.add(section_file(section))
    else:
      # Prepare to read
      readers = [supertensor_reader_t(section_file(child)) for child in children]
      for reader in readers:
        assert reader.header.block_size==block_size

      # We need to compute the four dimensional tensor A_ijkl.  The entire tensor cannot fit into RAM, so we do this in two
      # passes, the first considering moves in quadrants ij, the second considering moves in quadrants kl.  The first pass
      # writes a temporary tensor file to disk, and the second reads blocks from the temporary file and combines them with
      # the kl data before writing the final section file.

      # To ensure sufficient parallelism, we first rearrange the block dimensions of A_ijkl so that |i| <= |k| <= |j| <= |l|.

      # Compute and write the first (temporary) pass
      def open_writer(file):
        return supertensor_writer_t(file,section,block_size,filter(),level())
      with Log.scope('pass one'):
        tmp = tempfile.NamedTemporaryFile(prefix='section-tmp-%s'%show_section(section),suffix='.pentago')
        writer = open_writer(tmp.name)
        order = argsort(writer.header.shape)
        order[1],order[2] = order[2],order[1]
        compute_pass(writer,None,readers,order)
      with Log.scope('pass two'):
        first_pass = supertensor_reader_t(tmp.name)
        writer = open_writer(section_file(section))
        compute_pass(writer,first_pass,readers,order[::-1])

def verify(section):
  with Log.scope('verify %s'%show_section(section)):
    reader = supertensor_reader_t(section_file(section))
    random = Random(85421133)
    try:
      endgame_verify(reader,random,verify_samples())
    except RuntimeError,e:
      Log.write(str(e))
      if recurse():
        for child in section_children(section):
          verify(child)

def sparse_verify(section):
  with Log.scope('sparse verify %s'%show_section(section)):
    random = Random(85421133)
    sparse = tryfile.read(sparse_file(section))
    assert all(sparse['section']==section)
    samples = sparse_verify_samples()
    if samples<0 or samples>len(sparse['boards']):
      samples = len(sparse['boards'])
    Log.write('verifying %d samples'%samples)
    try:
      endgame_sparse_verify(section,sparse['boards'],sparse['wins'],random,samples)
    except RuntimeError,e:
      Log.write(str(e))
      if recurse():
        for child in section_children(section):
          sparse_verify(child)

def main():
  # Parse properties
  global section,block_size,symmetries,history,dir,samples
  parser.parse('Pentago endgame database computation',positional=[section])
  m = re.match('^\D*(?:\d\d-)?(\d{8})\D*$',section())
  if not m:
    raise ValueError('bad section %s'%section())
  section.set(m.group(1))
  section = asarray(map(int,m.group(1))).reshape(4,2)
  assert section_valid(section)
  block_size = block_size()
  symmetries = symmetries()
  history = history()
  samples = samples()
  dir = dir()

  # Verify that section is standardized to prevent accidental computation of unnecessary data
  standard = standardize_section(section,symmetries)
  if not all(section==standard):
    raise ValueError('refusing to compute nonstandard section %s (did you mean %s?)'%(show_section(section),show_section(standard)))

  # Make directory if necessary
  if not exists(dir):
    os.mkdir(dir)

  # Check history filename
  if history:
    if os.path.isdir(history):
      history = os.path.join(history,'history-%s.try'%show_section(section))
    if not history.endswith('.try'):
      raise ValueError('--history file "%s" does not end with .try'%history)

  # Configure logging
  Log.configure('endgame',0,0,100)
  Log.copy_to_file(os.path.join(dir,'log-%s'%show_section(section)),True)
  Log.write('command = %s'%parser.command())

  # Do whatever is necessary
  set_thread_history(bool(history))
  init_thread_pools(cpu_threads(),io_threads())
  if verify_samples() or sparse_verify_samples():
    init_supertable(21)
    if verify_samples():
      verify(section)
    if sparse_verify_samples():
      sparse_verify(section)
  else:
    try:
      compute(section)
    finally:
      report_thread_times(True)
      if history:
        Log.write('saving thread history to %s'%history)
        tryfile.write(history,thread_history())

if __name__=='__main__':
  main()
