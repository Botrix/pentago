#!/usr/bin/env python

from __future__ import division
from pentago import *
from other.core import *
from other.core.value import parser
from other.core.utility import tryfile
from other.gui import *
from pentago.interface import *
from OpenGL import GL
import glob

# Parse arguments
props = PropManager()
history_dir = props.add('history','').set_required(True).set_help('record thread execution history to given file').set_category('history')
dependency_depth = props.add('dependency_depth',10).set_help('search back this far when drawing selected events').set_category('history')
#short = props.add('short',1).set_help('events separated by less than this number of milliseconds will be merged').set_category('history')
#drop = props.add('drop',.1).set_help('kinds which take less than this amount of time won\'t be shown').set_category('history')
#mode = props.add('mode','rasterize').set_allowed('rasterize bar'.split()).set_help('rendering mode').set_category('history')
#resolution = props.add('resolution',(8*2048,10)).set_help('resolution of each thread in rasterization mode').set_category('history')
#vertical_separate = props.add('vertical_separate',False).set_category('history')
#save = props.add('save','').set_help('save the rasterized image to the given file').set_category('history')
parser.parse(props,'Thread history visualization',positional=[history_dir])

# Positioning is a bit strange.  We want the horizontal and vertical axes to operate entirely independently.  To do this, we'll take
# complete control over zoom, and let the naive other/gui camera control only translation.  Here goes:
scales = Prop('scales',(1,1))

# Picked point
picked = Prop('picked',(0,-1))

def read_history(dir):
  with Log.scope('read'):
    names = glob.glob(dir+'/history-r*')
    ranks = [None]*len(names)
    for name in names:
      m = re.search(r'history-r(\d+)',name)
      rank = int(m.group(1))
      data = fromfile(name,dtype=int64).reshape(-1,3)
      threads,kinds,_ = data[0]
      ranks[rank] = [[data[data[i][0]:data[i][1]] for kind in xrange(kinds) for i in (1+thread*kinds+kind,)] for thread in xrange(threads)]
  return [thread for rank in ranks for thread in rank]

def line_between_boxes(color,box0,box1):
  if 0:
    x0 = box0.clamp(box1.center())
    x1 = box1.clamp(box0.center())
  else:
    x0 = box0.center()
    x1 = box1.center()
  GL.glColor(color)
  GL.glBegin(GL.GL_LINES)
  gl_vertices([x0,x1])
  GL.glEnd()

class HistoryScene(Scene):
  def __init__(self):
    # Read history
    history = read_history(history_dir())

    # Determine bounds
    with Log.scope('warp'):
      start = min(events[:,1].min() for thread in history for events in thread if len(events))
      for thread in history:
        for events in thread:
          events[:,1:] -= start
      self.elapsed = 1e-6*max(events[:,2].max() for thread in history for events in thread if len(events))
      Log.write('elapsed = %g'%self.elapsed)
      self.history = history

    # Check dependencies
    with Log.scope('dependencies'):
      def sort_by_events(events):
        return events[argsort(events[:,0])] if len(events) else events
      self.event_sorted_history = map(curry(map,sort_by_events),history)
      check_dependencies(self.event_sorted_history)

    # Pick colors and generate legend information.
    # Use distinguishable colors for important entries, black for the rest
    with Log.scope('colors'):
      most = 7
      base_colors = wheel_color(arange(most)/most)
      random.seed(842953)
      random.shuffle(base_colors)
      self.kind_names = kind_names = time_kind_names()
      sums = zeros(len(kind_names))
      for k in xrange(len(kind_names)):
        if 'idle' not in kind_names[k]:
          sums[k] = sum(sum(thread[k][:,2]-thread[k][:,1]) for thread in history)
      order = argsort(-sums)
      Log.write('most important kinds = %s'%[kind_names[o] for o in order[:most]])
      self.colors = colors = [None]*len(kind_names)
      self.legend = legend = []
      other = .5*ones(3)
      for c,k in enumerate(order):
        try:
          colors[k] = base_colors[c]
          legend.append((colors[k],kind_names[k]))
        except IndexError:
          colors[k] = other
      legend.append((other,'other'))

    # Generate display list
    def draw_events():
      with Log.scope('drawing'):
        with gl_scope():
          GL.glDisable(GL.GL_LIGHTING)
          for n,thread in enumerate(history):
            for k,events in enumerate(thread):
              if len(events) and 'idle' not in self.kind_names[k]:
                quads = empty((len(events),4,2))
                quads[:,0::3,0] = events[:,1].reshape(-1,1)
                quads[:,1:3,0] = events[:,2].reshape(-1,1)
                quads[:,:2,1] = n+.1
                quads[:,2:,1] = n+.9
                GL.glColor(colors[k])
                GL.glBegin(GL.GL_QUADS)
                gl_vertices(quads)
                GL.glEnd()
    self.event_list = cache_render(draw_events)

    # Draw picked information
    def draw_picked():
      px,pn = picked()
      pn = int(pn)
      if pn>=0:
        thread = self.history[pn]
        kind,event = search_thread(thread,px)
        if kind<0:
          Log.write('thread %d, time %d: found nothing'%(pn,px))
        else:
          event = thread[kind][event]
          Log.write('thread %d, time %d: found %s from %d to %d'%(pn,px,str_event(event[0]),event[1],event[2]))
          text = '%s: %s'%(self.kind_names[kind],str_event(event[0]))
          GL.glColor(zeros(3))
          draw_text(((event[1]+event[2])/2,pn+.5,0),text,0)
          # Draw dependency edges
          work = [((pn,kind,event),0)]
          seen = set()
          max_depth = dependency_depth()
          def event_box((thread,kind,event)):
            return Box((event[1],thread+.1),(event[2],thread+.9))
          circles = []
          while work:
            source,depth = work.pop()
            key = source[0],source[1],tuple(source[2])
            if key not in seen and depth<max_depth:
              seen.add(key)
              source_box = event_box(source)
              circles.append(source_box.center())
              for dep in event_dependencies(self.event_sorted_history,*source):
                work.append((dep,depth+1))
                line_between_boxes(zeros(3),source_box,event_box(dep))
          self.circles.set(circles)
    self.circles = Prop('circles',None).set([])
    self.picked_list = cache_render(draw_picked)
 
  def bounding_box(self):
    return Box(zeros(3),(self.elapsed,len(self.history),0))

  def render(self,depth_picking,name_picking,view):
    # Draw history
    with gl_scope():
      sx,sy = scales()
      GL.glScale(1e-6*sx,sy,1)
      self.event_list().call()
      self.picked_list().call()
    # Draw circles around selected events
    circle = .05*polar(2*pi/30*arange(30))
    GL.glColor(zeros(3))
    for x in self.circles():
      GL.glBegin(GL.GL_LINE_LOOP)
      gl_vertices((1e-6*sx,sy)*x+circle)
      GL.glEnd()
    # Draw legend
    with gl_scope():
      w,h = view.cam.viewport[2:]
      set_matrices_window(w,h)
      GL.glDisable(GL.GL_LIGHTING)
      GL.glDisable(GL.GL_DEPTH_TEST)
      gap = 2
      height = 13
      color_width = 50
      char_width = 8
      legend = self.legend
      text_width = char_width*max(len(s) for c,s in legend)
      GL.glColor(.96,.96,.95)
      bx,by = w-(3*gap+color_width+text_width),h-(len(legend)*(height+gap)+gap)
      GL.glRectd(bx,by,w,h)
      for k,(c,s) in enumerate(legend[::-1]):
        GL.glColor(c)
        x,y = bx+gap,by+gap+k*(height+gap)
        GL.glRectd(x,y,x+color_width,y+height)
        GL.glColor(0,0,0)
        draw_text((x+color_width+gap,y,0),s,0)

def zoom(factor):
  sxy = [1,1]
  sxy[bool(qt_keyboard_modifiers()&QT_SHIFT)] = exp(1e-3*factor)
  scales.set(scales()*sxy)
  cam = main.view.cam
  cam.frame = Frames(cam.frame.t*hstack([sxy,1]),cam.frame.r)

def region(start,end):
  cam = main.view.cam
  A = cam.window_to_world()
  def warp(x):
    return homogeneous_times(A,hstack([x,0]))[:2]
  start = warp(start)
  end = warp(end)
  center = (start+end)/2/scales()
  goal_size = absolute(start-end)
  current_size = absolute(warp(zeros(2))-warp(cam.viewport[2:]))
  scales.set(scales()*current_size/goal_size) 
  cam.frame = Frames(hstack([center*scales(),0]),cam.frame.r)

def mouse_press(x,y,button,view):
  mods = qt_keyboard_modifiers()
  if mods&QT_SHIFT and not mods&QT_ALT:
    y = main.view.cam.viewport[3]-y
    x,y = homogeneous_times(view.cam.window_to_world(),(x,y,0))[:2]/scales()
    n = int(floor(y))
    if n<0 or n>=len(scene.history):
      n = -1
    picked.set((1e6*x,n))
    #print 'press: n %d, x %g'%(n,x)

# Visualize
Log.configure('draw history',0,0,100)
app = QEApp(sys.argv,True)
main = MainWindow(props)
main.view.toggle_2d_mode(True)
flat = InteractionMode('flat').set_zoom(zoom).set_region(region)
flat.track = 0
flat.select_region = QT_ALT
flat.mouse_press_callback = mouse_press
main.view.interaction_mode.set(flat)
scene = HistoryScene()
main.view.add_scene('history',scene)
main.init()
main.show_prop_section('history')
main.view.show_all(True)
app.run()
