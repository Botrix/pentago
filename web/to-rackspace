#!/usr/bin/env python
'''Upload solution files to rackspace, segmented along block boundaries for .pentago files.'''

from __future__ import division,print_function,unicode_literals,absolute_import
from contextlib import contextmanager
from math import *
import optparse
import pyrax
import time
import sys
import re
import os

# Options
usage = 'usage: %prog [options] [files...]\nUpload pentago data files to rackspace'
parser = optparse.OptionParser(usage)
parser.add_option('-n','--nop',action='store_true',help='upload nothing, but say what we would upload')
parser.add_option('--hashes',type=str,help='precomputed hash file')
options,paths = parser.parse_args()
if not options.hashes:
  parser.error('--hashes is required')

# Logging
indent = [0]

@contextmanager
def scope(name):
  start = time.time()
  print('  '*indent[0]+name)
  indent[0] += 1
  try:
    yield
  finally:
    indent[0] -= 1
    print('%*sEND %-*s%8.4f s'%(2*indent[0],'',60-2*indent[0]-4,name,time.time()-start))

def info(s):
  print('  '*indent[0]+s)

# Authenticate
with scope('authenticate'):
  pyrax.set_credential_file(os.environ['HOME']+'/.pyrax.cfg')

# Standard pyrax aliases from https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md
cs = pyrax.cloudservers
cf = pyrax.cloudfiles
cbs = pyrax.cloud_blockstorage
cdb = pyrax.cloud_databases
clb = pyrax.cloud_loadbalancers
dns = pyrax.cloud_dns
cnw = pyrax.cloud_networks

# Chunks must be no larger than 5 GB - 1
chunk_size = 5*2**30-1

def die(msg):
  print(msg,file=sys.stderr)
  sys.exit(1)

def load_hashes():
  assert 'md5s' in options.hashes
  hashes = {}
  for line in open(options.hashes):
    hash,name = line.split()
    hashes[name] = hash
  return hashes
hashes = load_hashes()

def quick_hash(name):
  return hashes[name]

def upload(container,name,file):
  with scope('chunk %s to %s'%(name,container.name)):
    with scope('checksum'):
      etag = quick_hash(name)
      info('etag = %s'%etag)
    if not options.nop:
      with scope('upload'):
        obj = container.upload_file(file,name,etag=etag)
        if etag != obj.etag:
          die('etag mismatch: local %s, upload %s'%(etag,obj.etag))

class slice_file(object):
  def __init__(self,path,lo,hi):
    self.f = open(path,'rb')
    self.seek(0)

  def seek(self,offset,whence=0):
    n = offset+{0:lo,2:hi}[whence]
    assert lo<=n<=hi
    self.f.seek(n)

  def tell(self):
    return self.f.tell()-lo

  def read(n):
    n = min(n,hi-self.f.tell())
    return self.f.read(n)

def upload_all(paths):
  # Verify that all files make sense
  file_pattern = re.compile('^(slice-\d+.pentago|sparse-\d+.npy|counts-\d+.npy)$')
  for path in paths:
    if not file_pattern.match(os.path.basename(path)):
      die('weird file: %s'%path)
    if not os.path.exists(path):
      die('nonexistent file: %s'%path)

  # Grab containers
  container = cf.get_container('pentago-edison-all')
  files = dict((f.name,f) for f in container.get_objects())

  # Upload each file
  with scope('upload'):
    for path in paths:
      name = os.path.basename(path) 
      size = os.stat(path).st_size
      chunks = (size+chunk_size-1)//chunk_size
      digits = int(log10(chunks))+1

      def cname(c):
        return '%s.%0*d'%(name,digits,c+1)
      def check_chunk(c):
        assert files[cname(c)].total_bytes==min(size,chunk_size*(c+1))-chunk_size*c
        with scope('check %s'%cname(c)):
          expected = quick_hash(cname(c))
          got = files[cname(c)].etag
          assert expected==got, 'expected %s, got %s'%(expected,got)

      if name in files:
        if size <= chunk_size:
          with scope('check %s'%name):
            assert files[name].etag==quick_hash(name)
        else:
          for c in xrange(chunks):
            check_chunk(c)
      else:
        if size <= chunk_size:
          upload(container,name,open(path,'rb'))
        else:
          for c in xrange(chunks):
            if cname(c) in files:
              check_chunk(c)
            else:
              upload(container,name,slice_file(path,chunk_size*c,min(size,chunk_size*(c+1))))

if __name__=='__main__':
  with scope('to rackspace'):
    upload_all(paths)
