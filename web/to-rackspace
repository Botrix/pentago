#!/usr/bin/env python
'''Upload solution files to rackspace, segmented along block boundaries for .pentago files.'''

from __future__ import division,print_function,unicode_literals,absolute_import
from contextlib import contextmanager
import optparse
import pyrax
import time
import sys
import re
import os

# Options
usage = 'usage: %prog [options] [files...]\nUpload pentago data files to rackspace'
parser = optparse.OptionParser(usage)
parser.add_option('-n','--nop',action='store_true',help='upload nothing, but say what we would upload')
parser.add_option('-c','--check',action='store_true',help='check hashes even if file already exists')
parser.add_option('--hashes',type=str,help='precomputed hash file')
options,paths = parser.parse_args()

# Logging
indent = [0]

@contextmanager
def scope(name):
  start = time.time()
  print('  '*indent[0]+name)
  indent[0] += 1
  try:
    yield
  finally:
    indent[0] -= 1
    print('%*sEND %-*s%8.4f s'%(2*indent[0],'',60-2*indent[0]-4,name,time.time()-start))

def info(s):
  print('  '*indent[0]+s)

# Authenticate
with scope('authenticate'):
  pyrax.set_credential_file(os.environ['HOME']+'/.pyrax.cfg')

# Standard pyrax aliases from https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md
cs = pyrax.cloudservers
cf = pyrax.cloudfiles
cbs = pyrax.cloud_blockstorage
cdb = pyrax.cloud_databases
clb = pyrax.cloud_loadbalancers
dns = pyrax.cloud_dns
cnw = pyrax.cloud_networks

def die(msg):
  print(msg,file=sys.stderr)
  sys.exit(1)

def load_hashes():
  assert options.hashes.endswith('md5s')
  hashes = {}
  for line in open(options.hashes):
    hash,name = line.split()
    hashes[name] = hash
  return hashes
if options.hashes:
  hashes = load_hashes()

def quick_hash(path):
  if options.hashes:
    return hashes[os.path.basename(path)]
  with scope('checksum'):
    return pyrax.utils.get_checksum(path)

def upload(container,name,path):
  with scope('chunk %s to %s'%(name,container.name)):
    with scope('checksum'):
      etag = quick_hash(path)
      info('etag = %s'%etag)
    if not options.nop:
      with scope('upload'):
        obj = container.upload_file(path,name,etag=etag)
        if etag != obj.etag:
          die('etag mismatch: local %s, upload %s'%(etag,obj.etag))

def upload_all(paths):
  # Verify that all files make sense
  file_pattern = re.compile('^(slice-\d+.pentago|sparse-\d+.npy|counts-\d+.npy)$')
  for path in paths:
    if not file_pattern.match(os.path.basename(path)):
      die('weird file: %s'%path)
    if not os.path.exists(path):
      die('nonexistent file: %s'%path)

  # Grab containers
  container = cf.get_container('pentago-edison-all')
  files = dict((f.name,f) for f in container.get_objects())

  # Upload each file
  with scope('upload'):
    for path in paths:
      name = os.path.basename(path) 
      if name in files:
        if options.check:
          with scope('check %s'%name):
            assert files[name].etag==quick_hash(path)
        else:
          info('skipping %s: already uploaded'%path)
      else:
        upload(container,name,path)

if __name__=='__main__':
  with scope('to rackspace'):
    upload_all(paths)
