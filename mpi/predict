#!/usr/bin/env python

from __future__ import division
from other.core import *
from other.core.value import parser
from pentago import *
from pentago.section import *
import re

# Mimic options to endgame-mpi
ranks = PropManager.add('ranks',0).set_required(True)
threads = PropManager.add('threads',0).set_required(True)
block_size = PropManager.add('block_size',8)
save = PropManager.add('save',0).set_required(True)
dir = PropManager.add('dir','data')
level = PropManager.add('level',26)
memory = PropManager.add('memory','').set_required(True)
section = PropManager.add('section','').set_required(True)
parser.parse('Endgame prediction script',positional=[section])

# 'Parse' simple properties
ranks = ranks()
threads = threads()
block_size = block_size()
save = save()

# Parse memory
m = re.match('^(\d+)(M|MB|G|GB)$',memory())
if not m:
  raise ValueError('weird memory limit %s'%memory())
memory = int(m.group(1))<<{'M':20,'G':30}[m.group(2)[0]]

# Parse section
m = re.match('^\D*(?:\d\d-)?(\d{8})\D*$',section())
if not m:
  raise ValueError('bad section %s'%section())
section = asarray(map(int,m.group(1))).reshape(4,2)

# Configure logging
Log.configure('predict',0,0,100)
Log.write('command = %s'%parser.command())

# Dump general information
with Log.scope('parameters'):
  Log.write('ranks = %d'%ranks)
  Log.write('threads / rank = %d'%threads)
  Log.write('section = %s'%show_section(section))
  Log.write('block size = %d'%block_size)
  Log.write('saved slices = %d'%save)
  Log.write('memory limit = %s'%large(memory))

line_cost = 2*64*8**3*420
def line_parallelism(base_memory):
  return (memory-base_memory)/line_cost

# Simulate execution
slices = descendent_sections(section)
prev_partition = None
max_blocks = 0
max_base_memory = 0
min_lines = 1<<30
max_total_memory = 0
max_save_memory = 0
for slice in reversed(xrange(len(slices))):
  if not len(slices[slice]):
    break
  with Log.scope('slice %d'%slice):
    partition = partition_t(ranks,block_size,slice,slices[slice],True)
    Log.write('blocks = %d'%partition.max_rank_blocks)
    Log.write('nodes = %d'%partition.max_rank_nodes)
    max_blocks = max(max_blocks,partition.max_rank_blocks)
    assert partition.max_rank_blocks<32767
    base_memory = max_rank_memory_usage(prev_partition,partition)
    max_base_memory = max(max_base_memory,base_memory)
    Log.write('base memory = %s'%large(base_memory))
    lines = line_parallelism(base_memory)
    min_lines = min(min_lines,lines)
    Log.write('line parallelism = %g'%lines)
    total_memory = base_memory+line_cost*max(0,int(floor(lines)))
    max_total_memory = max(max_total_memory,total_memory)
    Log.write('total memory = %s'%large(total_memory))
    prev_partition = partition
    if slice<=save:
      save_memory = 64*partition.max_rank_nodes
      Log.write('save memory = %s'%large(save_memory))
      max_save_memory = max(max_save_memory,save_memory)
with Log.scope('summary'):
  Log.write('blocks = %d'%max_blocks)
  Log.write('base memory = %s'%large(max_base_memory))
  Log.write('line parallelism = %g'%min_lines)
  Log.write('total memory = %s'%large(max_total_memory))
  Log.write('save memory = %s'%large(max_save_memory))

# Example runs:
#
# Mira (Blue Gene/Q): ./predict --ranks 49152 --threads 64 --save 18 --memory 8G 00000000
