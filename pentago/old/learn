#!/usr/bin/env python

from __future__ import division
import re
import fileinput
from numpy import *
from pentago.old.interface import *

game_pattern = re.compile(r'^(\d+) \(0, (-?[01]), \[([\d, ]+)\]\)$')

games = []
for line in fileinput.input():
  m = game_pattern.match(line)
  if not m:
    raise RuntimeError('weird line: %s'%line[:-1]) 
  games.append((int(m.group(1)),int(m.group(2)),fromstring(m.group(3),sep=',',dtype=uint64)))
print 'parsed %d games'%len(games)

# Partition positions into win, loss, tie
positions = {-1:[],0:[],1:[]}
for seed,result,game in games:
  positions[ result].append(game[ ::2])
  positions[-result].append(game[1::2])
for k,v in list(positions.items()):
  positions[k] = standardize(hstack(v))
print 'total positions = %d'%sum(map(len,positions.values()))
for name,k in [('wins',1),('ties',0),('losses',-1)]:
  print '%s = %d'%(name,len(positions[k]))

# Sort possibly starting moves by expected result
everything = unique(hstack(positions.values()))
starts = everything[sum(to_table(everything).reshape(-1,36),axis=1)==1]
for start in starts:
  counts = dict((k,sum(positions[k]==start)) for k in (-1,0,1))
  print '\nstart: wins %d, ties %d, losses %d, expectation %g'%(counts[1],counts[0],counts[-1],sum(k*v for k,v in counts.items())/sum(counts.values()))
  print to_table(start)

# Count number of unique positions in the database for each number of stones
counts = sum(to_table(everything).reshape(-1,36)!=0,axis=1)
print '\ntotals:'
for t in xrange(1,37):
  print '  %d stones, %d positions'%(t,sum(counts==t))
print

# Count lengths
counts = zeros(36+2,int)
for _,_,game in games:
  counts[len(game)] += 1
print 'lengths:'
for n in xrange(len(counts)):
  if counts[n]:
    print '  length %d, games %d'%(n,counts[n])
print
